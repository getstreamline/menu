{"version":3,"file":"menu.iife.js","sources":["../src/Menu.js","../src/index.js"],"sourcesContent":["const ESC_KEY = 'Escape';\nconst END_KEY = 'End';\nconst HOME_KEY = 'Home';\nconst LEFT_ARROW = 'ArrowLeft';\nconst UP_ARROW = 'ArrowUp';\nconst RIGHT_ARROW = 'ArrowRight';\nconst DOWN_ARROW = 'ArrowDown';\n\nconst HOVER_ENTER_TIMEOUT = 400;\nconst HOVER_MOVE_TIMEOUT = 40;\nconst HOVER_LEAVE_TIMEOUT = 400;\n\nlet lastSubmenuIndex = 0;\n\nfunction generateSubmenuId() {\n  const submenuIndex = lastSubmenuIndex + 1;\n  lastSubmenuIndex = submenuIndex;\n  return `sl-menu__submenu_${submenuIndex}`;\n}\n\nfunction isVisible(element) {\n  if (!element) return false;\n  const style = getComputedStyle(element);\n  return style.display !== 'none' && style.visibility !== 'hidden' && element.offsetParent !== null;\n}\n\nclass MenuItem {\n  constructor(menu, element) {\n    this.menu = menu;\n    this.element = element;\n    // Allow the link to be in a wrapper for styling purposes.\n    this.link = element.querySelector(':scope > a');\n    this.open = false;\n\n    if (!this.element.getAttribute('role')) {\n      this.element.setAttribute('role', 'none');\n    }\n    if (!this.link.getAttribute('role')) {\n      this.link.setAttribute('role', 'menuitem');\n    }\n\n    const submenuElement = element.querySelector(':scope > ul');\n    if (submenuElement) {\n      if (!submenuElement.getAttribute('id')) {\n        submenuElement.setAttribute('id', generateSubmenuId());\n      }\n\n      this.submenu = new menu.constructor(submenuElement, {\n        role: 'menu',\n        focusContainer: false,\n      });\n      this.element.classList.add('sl-menu--has-submenu');\n      this.link.setAttribute('aria-haspopup', 'menu')\n      this.link.setAttribute('aria-controls', submenuElement.getAttribute('id'));\n      this.toggle = document.createElement('button');\n      this.toggle.textContent = 'Toggle menu';\n      this.toggle.setAttribute('type', 'button');\n      this.toggle.classList.add('sl-menu__toggle');\n      this.toggle.setAttribute('aria-controls', submenuElement.getAttribute('id'));\n      this.toggle.setAttribute('tabindex', '-1');\n      // If the link is in a wrapper, this puts the toggle button in the wrapper for easier\n      // styling.\n      this.link.parentNode.insertBefore(this.toggle, this.link.nextSibling);\n      submenuElement.classList.add('sl-menu__submenu');\n      if (!submenuElement.getAttribute('aria-label')) {\n        submenuElement.setAttribute('aria-label', this.link.textContent);\n      }\n    }\n\n    this.update();\n  }\n\n  setOpen(open) {\n    if (!this.submenu) {\n      return;\n    }\n\n    this.open = open;\n    // Recursively close any submenus.\n    this.submenu.setOpenIndex(-1);\n\n    this.update();\n  }\n\n  update() {\n    if (!this.submenu) {\n      return;\n    }\n\n    if (this.open) {\n      this.element.classList.remove('sl-menu--closed');\n      this.element.classList.add('sl-menu--open');\n    } else {\n      this.element.classList.remove('sl-menu--open');\n      this.element.classList.add('sl-menu--closed');\n    }\n\n    // Set aria-expanded based on how these classes affect styling. These classes may not have an\n    // effect depending on responsive breakpoints.\n    // TODO: Efficiently listen for window resize events and update this attribute when breakpoints\n    // change.\n\n    const expanded = isVisible(this.submenu.element) ? 'true' : 'false';\n    this.link.setAttribute('aria-expanded', expanded);\n    this.toggle.setAttribute('aria-expanded', expanded);\n  }\n\n  focus() {\n    this.link.focus();\n  }\n}\n\nclass Menu {\n  constructor(element, options = {}) {\n    // Indicates our ARIA role, typically menubar for the root menu and menu for submenus.\n    this.element = element;\n    this.role = options.role || 'menubar';\n\n    // Determines whether we are the root menu and therefore the focus container that manages the\n    // roving tabindex.\n    this.focusContainer = typeof options.focusContainer === 'boolean' ? options.focusContainer : true;\n    this.items = [];\n    this.openIndex = -1;\n    this.hoverMode = true;\n    this.hoverIntent = false;\n\n    if (!this.element.getAttribute('role')) {\n      this.element.setAttribute('role', this.role);\n    }\n\n    // Triggered when any descendant receives focus.\n    this.element.addEventListener('focusin', (event) => {\n      // Update the roving tabindex.\n      if (this.focusContainer) {\n        const activeElement = event.target;\n        this.setActiveElement(activeElement);\n      }\n\n      // Detect our orientation so our keyboard navigation make sense.\n      this.setOrientation();\n    });\n\n    if (this.focusContainer) {\n      // The focusout event is unreliable across browsers, operating systems, front-end test\n      // frameworks, etc. so instead check whether an element that is not a descendant has received\n      // a focus-changing event.\n      document.addEventListener('keydown', (event) => {\n        if (this.openIndex !== -1 && !this.element.contains(event.target)) {\n          this.setActiveElement(this.items[this.openIndex].link);\n          this.setOpenIndex(-1);\n        }\n      });\n\n      document.addEventListener('click', (event) => {\n        if (this.openIndex !== -1 && !this.element.contains(event.target)) {\n          this.setActiveElement(this.items[this.openIndex].link);\n          this.setOpenIndex(-1);\n        }\n      });\n\n      document.addEventListener('focusin', (event) => {\n        if (this.openIndex !== -1 && !this.element.contains(event.target)) {\n          this.setActiveElement(this.items[this.openIndex].link);\n          this.setOpenIndex(-1);\n        }\n      });\n    }\n\n    // Close submenu when Escape key is pressed.\n    this.element.addEventListener('keydown', (event) => {\n      if (event.key === ESC_KEY && this.openIndex !== -1) {\n        const item = this.items[this.openIndex];\n        this.setOpenIndex(-1);\n        item.focus();\n\n        // Close one submenu at a time.\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    });\n\n    // Detect whether hover mode should be enabled.\n    this.element.addEventListener('mouseenter', () => {\n      this.setHoverMode();\n    });\n\n    let hoverTimeout;\n    let hoverMoveTimeout;\n    Array.from(this.element.children).forEach((itemElement, index) => {\n      const item = new MenuItem(this, itemElement);\n      this.items.push(item);\n\n      // Set up all menu item links for roving tabindex.\n      item.link.setAttribute('tabindex', '-1');\n\n      itemElement.addEventListener('keydown', (event) => {\n        // Determine the keys for different behaviors based on our orientation.\n        const openKey = this.orientation === 'horizontal' ? DOWN_ARROW : RIGHT_ARROW;\n        const closeKey = this.orientation === 'horizontal' ? UP_ARROW : LEFT_ARROW;\n        const prevKey = this.orientation === 'horizontal' ? LEFT_ARROW : UP_ARROW;\n        const nextKey = this.orientation === 'horizontal' ? RIGHT_ARROW : DOWN_ARROW;\n\n        switch (event.key) {\n          case openKey:\n            if (item.submenu && this.openIndex !== index) {\n              this.setOpenIndex(index);\n              item.submenu.focusFirstItem();\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case closeKey:\n            if (item.submenu && this.openIndex === index) {\n              this.setOpenIndex(-1);\n              item.focus();\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case prevKey:\n            if (index > 0) {\n              // Determine whether this event bubbled up from an open submenu.\n              const bubbled = index === this.openIndex;\n\n              // Only allow bubbling from an open submenu on a horizontal menu.\n              if (!bubbled || this.orientation === 'horizontal') {\n                const prevItem = this.items[index - 1];\n\n                // If a submenu is open, try to open the previous item's submenu.\n                if (prevItem.submenu && this.openIndex !== -1) {\n                  this.setOpenIndex(index - 1);\n                  prevItem.submenu.focusFirstItem();\n                } else {\n                  this.setOpenIndex(-1);\n                  prevItem.focus();\n                }\n              }\n\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case nextKey:\n            if (index < this.items.length - 1) {\n              const nextItem = this.items[index + 1];\n\n              // If a submenu is open, try to open the previous item's submenu.\n              if (nextItem.submenu && this.openIndex !== -1) {\n                this.setOpenIndex(index + 1);\n                nextItem.submenu.focusFirstItem();\n              } else {\n                this.setOpenIndex(-1);\n                nextItem.focus();\n              }\n            }\n\n            // We're at the end of the menu, don't allow this to bubble and close the menu or\n            // something.\n            event.stopPropagation();\n            event.preventDefault();\n            break;\n\n          case HOME_KEY:\n            if (this.items.length > 0) {\n              const firstItem = this.items[0];\n\n              // If a submenu is open, try to open the first item's submenu.\n              if (firstItem.submenu && this.openIndex !== -1) {\n                this.setOpenIndex(1);\n                firstItem.submenu.focusFirstItem();\n              } else {\n                this.setOpenIndex(-1);\n                firstItem.focus();\n              }\n\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          case END_KEY:\n            if (this.items.length > 0) {\n              const lastItem = this.items[this.items.length - 1];\n\n              // If a submenu is open, try to open the last item's submenu.\n              if (lastItem.submenu && this.openIndex !== -1) {\n                this.setOpenIndex(this.items.length - 1);\n                lastItem.submenu.focusFirstItem();\n              } else {\n                this.setOpenIndex(-1);\n                lastItem.focus();\n              }\n\n              event.stopPropagation();\n              event.preventDefault();\n            }\n            break;\n\n          default:\n          // Ignore all other keys.\n        }\n      });\n\n      itemElement.addEventListener('mouseenter', () => {\n        if (!this.hoverMode) {\n          return;\n        }\n\n        if (hoverTimeout) {\n          clearTimeout(hoverTimeout);\n          hoverTimeout = undefined;\n        }\n        if (this.hoverIntent) {\n          this.setOpenIndex(index);\n        } else {\n          // Assume hover intent HOVER_ENTER_TIMEOUT after the mouse enters.\n          hoverTimeout = setTimeout(() => {\n            if (!this.hoverMode) {\n              return;\n            }\n\n            this.hoverIntent = true;\n            this.setOpenIndex(index);\n          }, HOVER_ENTER_TIMEOUT);\n        }\n\n        if (hoverMoveTimeout) {\n          clearTimeout(hoverMoveTimeout);\n          hoverMoveTimeout = undefined;\n        }\n      });\n\n      itemElement.addEventListener('mousemove', () => {\n        if (!this.hoverMode || this.hoverIntent) {\n          return;\n        }\n\n        if (hoverMoveTimeout) {\n          clearTimeout(hoverMoveTimeout);\n        }\n        // Assume hover intent HOVER_MOVE_TIMEOUT after the mouse last moved (i.e. stopped moving).\n        hoverMoveTimeout = setTimeout(() => {\n          this.hoverIntent = true;\n          this.setOpenIndex(index);\n        }, HOVER_MOVE_TIMEOUT);\n      });\n\n      itemElement.addEventListener('mouseleave', () => {\n        if (!this.hoverMode) {\n          return;\n        }\n\n        if (hoverTimeout) {\n          clearTimeout(hoverTimeout);\n        }\n        // Clear hover intent HOVER_LEAVE_TIMEOUT after the mouse leaves.\n        hoverTimeout = setTimeout(() => {\n          if (this.openIndex === index) {\n            this.hoverIntent = false;\n            this.setOpenIndex(-1);\n          }\n        }, HOVER_LEAVE_TIMEOUT);\n\n        if (hoverMoveTimeout) {\n          clearTimeout(hoverMoveTimeout);\n          hoverMoveTimeout = undefined;\n        }\n      });\n\n      if (item.submenu && item.toggle) {\n        item.toggle.addEventListener('click', () => {\n          if (this.openIndex === index) {\n            this.setOpenIndex(-1);\n            item.focus();\n          } else {\n            this.setOpenIndex(index);\n            item.submenu.focusFirstItem();\n          }\n        });\n      }\n    });\n\n    // Move the roving tabindex to the first top level menu item.\n    if (this.focusContainer && this.items.length > 0) {\n      this.setActiveElement(this.items[0].link);\n    }\n    this.setOrientation();\n    this.update();\n  }\n\n  /**\n   * Updates the roving tabindex with the given descendant.\n   */\n  setActiveElement(element) {\n    // Ensure we keep a roving tabindex on one of our descendants, otherwise we effectively become\n    // impossible to focus.\n    if (!this.element.contains(element)) {\n      return;\n    }\n\n    if (this.prevActiveElement) {\n      this.prevActiveElement.setAttribute('tabindex', '-1');\n    }\n\n    const nextActiveElement = element;\n    nextActiveElement.setAttribute('tabindex', '0');\n    this.prevActiveElement = nextActiveElement;\n  }\n\n  /**\n   * Automatically sets our orientation and updates the ARIA orientation attribute.\n   */\n  setOrientation() {\n    if (isVisible(this.element) && this.items.length >= 2) {\n      const firstOffset = this.items[0].element.getBoundingClientRect();\n      const secondOffset = this.items[1].element.getBoundingClientRect();\n      const dx = Math.abs(secondOffset.left - firstOffset.left);\n      const dy = Math.abs(secondOffset.top - firstOffset.top);\n\n      if (dx > dy) {\n        this.orientation = 'horizontal';\n      } else {\n        this.orientation = 'vertical';\n      }\n    } else if (this.role === 'menubar') {\n      this.orientation = 'horizontal';\n    } else {\n      this.orientation = 'vertical';\n    }\n\n    this.element.setAttribute('aria-orientation', this.orientation);\n  }\n\n  /**\n   * Automatically sets hover mode based on toggle button visibility.\n   */\n  setHoverMode() {\n    this.hoverMode = !this.items.some(item => item.toggle && isVisible(item.toggle));\n  }\n\n  /**\n   * Opens the given submenu or closes the currently opened submenu.\n   *\n   * @param {number} index\n   *   The index of the menu item whose submenu is open, or -1 if no submenu is open.\n   */\n  setOpenIndex(index) {\n    this.openIndex = index;\n    this.update();\n  }\n\n  /**\n   * Update the DOM based on state changes.\n   */\n  update() {\n    this.items.forEach((item, index) => {\n      item.setOpen(index === this.openIndex);\n    });\n  }\n\n  /**\n   * Helper to move focus to the first item in this menu.\n   */\n  focusFirstItem() {\n    if (this.items.length === 0) {\n      return;\n    }\n\n    this.items[0].focus();\n  }\n}\n\nexport default Menu;\n","import Menu from './Menu.js';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const elements = document.querySelectorAll('.sl-menu');\n\n  elements.forEach((element) => {\n    new Menu(element);\n  });\n});\n"],"names":["LEFT_ARROW","UP_ARROW","RIGHT_ARROW","DOWN_ARROW","lastSubmenuIndex","isVisible","element","style","getComputedStyle","display","visibility","offsetParent","MenuItem","constructor","menu","this","link","querySelector","open","getAttribute","setAttribute","submenuElement","submenuIndex","generateSubmenuId","submenu","role","focusContainer","classList","add","toggle","document","createElement","textContent","parentNode","insertBefore","nextSibling","update","setOpen","setOpenIndex","remove","expanded","focus","Menu","options","hoverTimeout","hoverMoveTimeout","items","openIndex","hoverMode","hoverIntent","addEventListener","event","activeElement","target","setActiveElement","setOrientation","contains","key","item","stopPropagation","preventDefault","setHoverMode","Array","from","children","forEach","itemElement","index","push","openKey","orientation","closeKey","prevKey","nextKey","focusFirstItem","prevItem","length","nextItem","firstItem","lastItem","clearTimeout","setTimeout","prevActiveElement","nextActiveElement","firstOffset","getBoundingClientRect","secondOffset","dx","Math","abs","left","dy","top","some","querySelectorAll"],"mappings":"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"}